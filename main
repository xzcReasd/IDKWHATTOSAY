
-- Load optimization variables table
local variablesURL = 'https://raw.githubusercontent.com/xzcReasd/IDKWHATTOSAY/refs/heads/main/Var'
local variables = loadstring(game:HttpGet(variablesURL))()

-- Load ImGui library
local SourceURL = 'https://raw.githubusercontent.com/xzcReasd/IDKWHATTOSAY/refs/heads/main/Source'
ImGui = loadstring(game:HttpGet(SourceURL))()

-- Sound management functions
local downloadSound = (function(SoundName, SoundUrl)
    local SoundPath = string.format("sounds/%s", SoundName)
    if not isfile(SoundPath) then
        writefile(SoundPath, game:HttpGet(SoundUrl))
    end
    return SoundPath
end)

local function getAsset(filename)
    if isfile("sounds/" .. filename) then
        return getcustomasset("sounds/" .. filename)
    end
    return nil
end

-- Create sounds directory if it doesn't exist
if not isfolder("sounds") then
    makefolder("sounds")
end

-- Download custom sounds
local sounds = {
    BlackPencil = "https://github.com/Shatapmatehabibi/Hitsounds/raw/main/bananapencil.mp3.mp3",
    UWU = "https://github.com/CongoOhioDog/SoundS/blob/main/Uwu.mp3?raw=true",
    Plooh = "https://github.com/CongoOhioDog/SoundS/blob/main/plooh.mp3?raw=true",
    Hrntai = "https://github.com/CongoOhioDog/SoundS/blob/main/Hrntai.wav?raw=true",
    Henta01 = "https://github.com/CongoOhioDog/SoundS/blob/main/henta01.wav?raw=true",
    Bruh = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20bruh%20sample.mp3?raw=true",
    BoneBreakage = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20bone%20breakage.mp3?raw=true",
    Fein = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20highly%20defined%20fein.mp3?raw=true",
    Unicorn = "https://github.com/CongoOhioDog/SoundS/blob/main/shiny%20unicorn%20for%20dh%20_%20psalms.mp3?raw=true",
    Kitty = "https://github.com/CongoOhioDog/SoundS/blob/main/Kitty.mp3?raw=true",
    Bird = "https://github.com/CongoOhioDog/SoundS/blob/main/bird%20chirping%20for%20DH%20_%20psalms%20audio.mp3?raw=true",
    BirthdayCake = "https://github.com/CongoOhioDog/SoundS/blob/main/Birthday%20cake%20for%20dh%20_%20psalms.mp3?raw=true", 
    KenCarson = "https://github.com/CongoOhioDog/SoundS/blob/main/ken_carson_-_jennifer_s_body_offici(2).mp3?raw=true"
}

-- Download all sounds
for name, url in pairs(sounds) do
    _G[name .. "Path"] = downloadSound(name .. ".mp3", url)
end

-- Initialize Silent Aim variables first
local silentAimVars = variables and variables.SilentAim or getgenv().SilentAim
if not silentAimVars then
    silentAimVars = {
        Options = { Enabled = false },
        Silent = { 
            PredictionXZ = 0.12362, 
            PredictionY = 0.12362, 
            Part = "HumanoidRootPart",
            ForceHit = {
                Enabled = false,
                State = true
            },
            MagicBullets = {
                Enabled = false
            }
        },
        Misc = { 
            Checks = { 
                Resolver = { Enabled = false, Type = "Calculate CFrame" },
                WallCheck = { Enabled = false },
                KOCheck = { Enabled = false },
                SitCheck = { Enabled = false },
                GrabCheck = { Enabled = false }
            },
            TargetMode = "Nuker",
            StickyTarget = {
                Enabled = false,
                Key = Enum.KeyCode.X,
                Target = nil
            },
            KillAura = {
                MaxTargets = 3,
                Index = 1,
                LastSwitch = 0
            }
        }
    }
    getgenv().SilentAim = silentAimVars
end

-- Initialize configs
if not getgenv().HitSoundsConfig then
    getgenv().HitSoundsConfig = {
        Enabled = false,
        Selected = "RIFK7",
        Volume = 0.5,
        Pitch = 1.0
    }
end

if not getgenv().HitChamsConfig then
    getgenv().HitChamsConfig = {
        Enabled = false,
        Transparency = 0.5,
        Duration = 1.0,
        Color = Color3.fromRGB(255, 0, 0),
        Material = Enum.Material.ForceField
    }
end

if not getgenv().IndicatorConfig then
    getgenv().IndicatorConfig = {
        Enabled = false,
        Selected = "skull",
        Size = 2,
        Transparency = 0.5
    }
end

-- Define available indicator images
local indicatorImages = {
    ["skull"] = "108770683919433",
    ["trollface"] = "130642148173502"
}

-- Create main window
local window = ImGui:CreateWindow({
    Title = "Freedom.TAPBOT",
    Size = UDim2.new(0, 900, 0, 600),
})

window:Center()

-- Create tabs
local tabRage = window:CreateTab({
    Name = "RAGE"
})

local rageHeader = tabRage:CollapsingHeader({
    Title = "ragebot"
})

-- Add visual section
local visualHeader = tabRage:CollapsingHeader({
    Title = "visual"
})

-- Add hitsounds section inside visual
local hitsoundsHeader = visualHeader:CollapsingHeader({
    Title = "hitsounds"
})

-- Добавить секцию HitChams в visual
local hitchamsHeader = visualHeader:CollapsingHeader({
    Title = "hitchams"
})

hitchamsHeader:Checkbox({
    Label = "Включить HitChams",
    Value = getgenv().HitChamsConfig.Enabled,
    Callback = function(self, value)
        getgenv().HitChamsConfig.Enabled = value
    end
})

hitchamsHeader:Slider({
    Label = "Прозрачность",
    Value = getgenv().HitChamsConfig.Transparency,
    MinValue = 0,
    MaxValue = 1,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitChamsConfig.Transparency = value
        return true
    end
})

hitchamsHeader:Slider({
    Label = "Длительность",
    Value = getgenv().HitChamsConfig.Duration,
    MinValue = 0.1,
    MaxValue = 5,
    Step = 0.1,
    Format = "%.1f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitChamsConfig.Duration = value
        return true
    end
})

hitchamsHeader:Combo({
    Label = "Материал",
    Items = {"ForceField", "Neon", "Plastic", "SmoothPlastic", "Glass"},
    Placeholder = tostring(getgenv().HitChamsConfig.Material.Name),
    Callback = function(self, value)
        getgenv().HitChamsConfig.Material = Enum.Material[value]
    end
})

hitchamsHeader:InputText({
    Label = "Цвет (R,G,B)",
    Value = string.format("%d,%d,%d", getgenv().HitChamsConfig.Color.R*255, getgenv().HitChamsConfig.Color.G*255, getgenv().HitChamsConfig.Color.B*255),
    PlaceHolder = "255,0,0",
    Callback = function(self, value)
        local r,g,b = value:match("(%d+),(%d+),(%d+)")
        r,g,b = tonumber(r), tonumber(g), tonumber(b)
        if r and g and b then
            getgenv().HitChamsConfig.Color = Color3.fromRGB(r,g,b)
        end
    end
})

-- Add indicator section inside visual
local indicatorHeader = visualHeader:CollapsingHeader({
    Title = "indicator"
})

-- Add indicator controls
indicatorHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().IndicatorConfig.Enabled,
    Callback = function(self, value)
        getgenv().IndicatorConfig.Enabled = value
    end
})

indicatorHeader:Combo({
    Label = "Image",
    Items = {"skull", "trollface"},
    Placeholder = getgenv().IndicatorConfig.Selected or "skull",
    Callback = function(self, value)
        getgenv().IndicatorConfig.Selected = value
        local billboard = workspace:FindFirstChild("PP")
        if billboard and billboard:FindFirstChild("img3") then
            local selected = value or "skull"
            billboard.img3.Image = "rbxassetid://" .. (indicatorImages[selected] or indicatorImages["skull"])
        end
    end
})

-- Combine and deduplicate hitsounds
local hitsoundsList = {
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bubble"] = "rbxassetid://9102092728",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Cod"] = "rbxassetid://160432334",
    ["Bameware"] = "rbxassetid://6565367558",
    ["Neverlose"] = "rbxassetid://6565370984",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Rust"] = "rbxassetid://6565371338",
    ["BlackPencil"] = getAsset("BlackPencil.mp3"),
    ["UWU"] = getAsset("Uwu.mp3"),
    ["Plooh"] = getAsset("plooh.mp3"),
    ["Moan"] = getAsset("Hrntai.mp3"),
    ["Hentai"] = getAsset("Henta01.mp3"),
    ["Bruh"] = getAsset("Bruh.mp3"),
    ["BoneBreakage"] = getAsset("BoneBreakage.mp3"),
    ["Fein"] = getAsset("Fein.mp3"),
    ["Unicorn"] = getAsset("Unicorn.mp3"),
    ["Kitty"] = getAsset("Kitty.mp3"),
    ["Bird"] = getAsset("Bird.mp3"),
    ["BirthdayCake"] = getAsset("BirthdayCake.mp3"),
    ["KenCarson"] = getAsset("KenCarson.mp3")
}

-- Create array of sound names for Combo
local soundNames = {}
for name, _ in pairs(hitsoundsList) do
    table.insert(soundNames, name)
end
table.sort(soundNames) -- Sort alphabetically

-- Add hitsound controls
hitsoundsHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().HitSoundsConfig.Enabled,
    Callback = function(self, value)
        getgenv().HitSoundsConfig.Enabled = value
    end
})

hitsoundsHeader:Combo({
    Label = "Sound",
    Items = soundNames,
    Placeholder = getgenv().HitSoundsConfig.Selected,
    Callback = function(self, value)
        getgenv().HitSoundsConfig.Selected = value
    end
})

hitsoundsHeader:Slider({
    Label = "Volume",
    Value = HitSoundsConfig.Volume,
    MinValue = 1,
    MaxValue = 3,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitSoundsConfig.Volume = value
        return true
    end
})

hitsoundsHeader:Slider({
    Label = "Pitch",
    Value = HitSoundsConfig.Pitch,
    MinValue = 0.1,
    MaxValue = 3,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitSoundsConfig.Pitch = value
        return true
    end
})

-- Create other tabs
local tabMisc = window:CreateTab({ Name = "MISC" })
local tabVisual = window:CreateTab({ Name = "VISUAL" })
local tabPlayer = window:CreateTab({ Name = "PLAYER" })
local tabConfig = window:CreateTab({ Name = "CONFIG" })

-- Silent Aim CollapsingHeader
if silentAimVars and silentAimVars.Options then
    silentAimVars.Options.Enabled = false
    if silentAimVars.Misc and silentAimVars.Misc.Checks and silentAimVars.Misc.Checks.Resolver then
        silentAimVars.Misc.Checks.Resolver.Enabled = false
    end
    if not silentAimVars.Misc.KillAura then
        silentAimVars.Misc.KillAura = { MaxTargets = 3, Index = 1, LastSwitch = 0 }
    end
end

local resolverTypes = { "None", "Calculate CFrame", "Move direction", "Velocity" }
local targetModes = { "Nuker", "Sticky", "KillAura" }

local aimPartsList = {"HumanoidRootPart", "Head", "UpperTorso", "LowerTorso", "LeftFoot", "RightFoot", "LeftHand", "RightHand"}

if not silentAimVars.Silent.AirPart then
    silentAimVars.Silent.AirPart = "Head"
end
if not silentAimVars.Silent.Part then
    silentAimVars.Silent.Part = "HumanoidRootPart"
end




rageHeader:Checkbox({
    Label = "Enable",
    Value = silentAimVars.Options.Enabled,
    Callback = function(self, value)
        silentAimVars.Options.Enabled = value
    end
})

rageHeader:Checkbox({
    Label = "ForceHit",
    Value = silentAimVars.Silent.ForceHit.Enabled,
    Callback = function(self, value)
        silentAimVars.Silent.ForceHit.Enabled = value
        silentAimVars.Silent.ForceHit.State = true
    end
})

rageHeader:Checkbox({
    Label = "MagicBullets",
    Value = silentAimVars.Silent.MagicBullets.Enabled,
    Callback = function(self, value)
        silentAimVars.Silent.MagicBullets.Enabled = value
    end
})

rageHeader:InputText({
    Label = "PredXZ",
    Value = tostring(silentAimVars.Silent.PredictionXZ),
    PlaceHolder = "Enter Prediction XZ",
    Callback = function(self, value)
        local num = tonumber(value)
        if num then
            silentAimVars.Silent.PredictionXZ = num
        end
    end
})

rageHeader:InputText({
    Label = "PredY",
    Value = tostring(silentAimVars.Silent.PredictionY),
    PlaceHolder = "Enter Prediction Y",
    Callback = function(self, value)
        local num = tonumber(value)
        if num then
            silentAimVars.Silent.PredictionY = num
        end
    end
})

rageHeader:Combo({
    Label = "Resolver",
    Items = resolverTypes,
    Placeholder = silentAimVars.Misc.Checks.Resolver.Type or "None",
    Callback = function(self, value)
        if value == "None" then
            silentAimVars.Misc.Checks.Resolver.Enabled = false
        else
            silentAimVars.Misc.Checks.Resolver.Enabled = true
            silentAimVars.Misc.Checks.Resolver.Type = value
        end
    end
})

-- Target Mode Selection
rageHeader:Combo({
    Label = "SelectTargetMode",
    Items = targetModes,
    Placeholder = silentAimVars.Misc.TargetMode,
    Callback = function(self, value)
        silentAimVars.Misc.TargetMode = value
        if value == "Nuker" then
            silentAimVars.Misc.StickyTarget.Target = nil
        end
    end
})

-- Sticky Target Keybind
rageHeader:Keybind({
    Label = "StickyKey",
    Value = silentAimVars.Misc.StickyTarget.Key,
    Callback = function(self, value)
        silentAimVars.Misc.StickyTarget.Key = value
    end
})

rageHeader:Slider({
    Label = "KillAuraTargets",
    Value = silentAimVars.Misc.KillAura.MaxTargets,
    MinValue = 1,
    MaxValue = 10,
    Callback = function(self, value)
        silentAimVars.Misc.KillAura.MaxTargets = math.floor(value)
    end
})

-- Checks Header
local checksHeader = rageHeader:CollapsingHeader({
    Title = "Checks",
    Open = false
})

checksHeader:Checkbox({
    Label = "Wall",
    Value = silentAimVars.Misc.Checks.WallCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.WallCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Knocked",
    Value = silentAimVars.Misc.Checks.KOCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.KOCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Seat",
    Value = silentAimVars.Misc.Checks.SitCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.SitCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Grabbed",
    Value = silentAimVars.Misc.Checks.GrabCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.GrabCheck.Enabled = value
    end
})

-- ВНЕДРЕНИЕ САМОГО АИМБОТА (Silent Aim)
local SilentAim = getgenv().SilentAim
if getgenv().Loaded then return end

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local FindFirstChild = game.FindFirstChild
local FindPartOnRayWithIgnoreList = Workspace.FindPartOnRayWithIgnoreList
local GetPlayers = Players.GetPlayers
local GetMouseLocation = UserInputService.GetMouseLocation
local WorldToViewportPoint = Camera.WorldToViewportPoint
local NewVector2 = Vector2.new
local NewCFrame = CFrame.new
local NewRay = Ray.new
local TableFind = table.find
local IsA = game.IsA
local Inf = math.huge

local function IsPlayerAlive(player)
    return player and player.Character and FindFirstChild(player.Character, "Humanoid") and player.Character.Humanoid.Health > 0
end

local function BehindWall(character)
    local targetPosition = character.HumanoidRootPart.Position
    local cameraPosition = Camera.CFrame.Position
    local distance = (targetPosition - cameraPosition).Magnitude
    local hitPart, hitPosition = FindPartOnRayWithIgnoreList(
        Workspace,
        NewRay(cameraPosition, (targetPosition - cameraPosition).Unit * distance),
        { LocalPlayer.Character, character }
    )
    return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

local function isPlayerKO(player)
    if not player.Character then
        return false
    end
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if bodyEffects then
        local KO = bodyEffects:FindFirstChild("K.O")
        if KO and KO:IsA("BoolValue") and KO.Value then
            return true
        end
    end
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart and humanoidRootPart.Anchored then
        return true
    end
    return false
end

local function isPlayerSeated(player)
    if not player.Character then
        return false
    end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.SeatPart then
        return true
    end
    return false
end

local function isPlayerGrabbed(player)
    if not player or not player.Character then return false end
    return player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
end

local function WallCheck(character)
    if not SilentAim.Misc.Checks.WallCheck.Enabled then
        return true
    end
    if not character then return false end
    return not BehindWall(Players:GetPlayerFromCharacter(character))
end

local function PassesChecks(player)
    if not player or not player.Character then return false end
    
    if not IsPlayerAlive(player) then return false end
    
    if SilentAim.Misc.Checks.KOCheck.Enabled and isPlayerKO(player) then return false end
    if SilentAim.Misc.Checks.SitCheck.Enabled and isPlayerSeated(player) then return false end
    if SilentAim.Misc.Checks.GrabCheck.Enabled and isPlayerGrabbed(player) then return false end
    
    return true
end

-- Resolver Variables
local lastPosition = nil
local lastUpdateTime = nil
local predictedPosition = nil

local function getPredictedPosition(targetPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
        local aimPartPos = targetPlayer.Character[silentAimVars.Silent.Part].Position

        if not lastPosition or not lastUpdateTime then
            lastPosition = aimPartPos
            lastUpdateTime = tick()
            predictedPosition = aimPartPos
            return predictedPosition
        end

        local currentTime = tick()
        local deltaTime = currentTime - lastUpdateTime

        local predictionResolver = silentAimVars.Misc.Checks.Resolver.Type
        if predictionResolver == "Velocity" then
            local velocity = targetPlayer.Character[silentAimVars.Silent.Part].Velocity
            predictedPosition = aimPartPos + Vector3.new(
                velocity.X * silentAimVars.Silent.PredictionXZ,
                velocity.Y * silentAimVars.Silent.PredictionY,
                velocity.Z * silentAimVars.Silent.PredictionXZ
            )
        elseif predictionResolver == "Move direction" then
            predictedPosition = aimPartPos + (targetPlayer.Character.Humanoid.MoveDirection * (silentAimVars.Silent.PredictionXZ * 10))
        elseif predictionResolver == "Calculate CFrame" then
            if (aimPartPos - lastPosition).Magnitude < 0.001 then
                predictedPosition = aimPartPos
            else
                local distance = (aimPartPos - lastPosition).Magnitude
                local predictedDistance = (distance / deltaTime) * (0.1 * (silentAimVars.Silent.PredictionXZ * 10))
                predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance

                local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * silentAimVars.Silent.PredictionY)
                predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
            end
        end

        lastUpdateTime = currentTime
        lastPosition = aimPartPos
        return predictedPosition
    end
    return nil
end

local function GetTargetAimPart(player)
    if not player or not player.Character then return silentAimVars.Silent.Part end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local state = humanoid:GetState()
        if state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
            return silentAimVars.Silent.AirPart or silentAimVars.Silent.Part
        end
    end
    return silentAimVars.Silent.Part
end

local function GetClosestPlayerToCursor()
    if not SilentAim or not SilentAim.Silent then return nil end
    
    local shortestDistance = math.huge
    local closestPlayer = nil
    local mousePosition = GetMouseLocation(UserInputService)
    for _, player in next, GetPlayers(Players) do
        if player and player.Character then
            if player ~= LocalPlayer and PassesChecks(player) and WallCheck(player.Character) then
                local partName = GetTargetAimPart(player)
                local targetPart = player.Character:FindFirstChild(partName)
                if targetPart then
                    local onScreenPosition, isOnScreen = WorldToViewportPoint(Camera, targetPart.Position)
                    if isOnScreen then
                        local distance = (NewVector2(onScreenPosition.X, onScreenPosition.Y) - mousePosition).Magnitude
                        if distance < shortestDistance then
                            closestPlayer = player
                            shortestDistance = distance
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end

local function GetKillAuraTargets()
    local targets = {}
    local part = SilentAim.Silent.Part
    for _, player in next, GetPlayers(Players) do
        if player and player.Character and player ~= LocalPlayer and PassesChecks(player) and WallCheck(player.Character) then
            local targetPart = player.Character:FindFirstChild(part)
            if targetPart then
                local onScreenPosition, isOnScreen = WorldToViewportPoint(Camera, targetPart.Position)
                if isOnScreen then
                    table.insert(targets, player)
                end
            end
        end
    end
    return targets
end

-- Handle sticky target key press
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and SilentAim and SilentAim.Misc and SilentAim.Misc.StickyTarget and input.KeyCode == SilentAim.Misc.StickyTarget.Key then
        if SilentAim.Misc.TargetMode == "Sticky" then
            if SilentAim.Misc.StickyTarget.Target then
                SilentAim.Misc.StickyTarget.Target = nil
            else
                SilentAim.Misc.StickyTarget.Target = GetClosestPlayerToCursor()
            end
        end
    end
end)

local function GetTargetPlayer()
    if not SilentAim or not SilentAim.Options or not SilentAim.Options.Enabled then return nil end
    if SilentAim.Misc.TargetMode == "Sticky" then
        local stickyTarget = SilentAim.Misc.StickyTarget.Target
        if stickyTarget and stickyTarget.Character and IsPlayerAlive(stickyTarget) and PassesChecks(stickyTarget) and WallCheck(stickyTarget.Character) then
            return stickyTarget
        end
        SilentAim.Misc.StickyTarget.Target = nil
        return nil
    elseif SilentAim.Misc.TargetMode == "KillAura" then
        local now = tick()
        local killaura = SilentAim.Misc.KillAura
        local targets = GetKillAuraTargets()
        if #targets == 0 then return nil end
        if killaura.Index > #targets then killaura.Index = 1 end
        if now - (killaura.LastSwitch or 0) > 0.01 then -- 20 раз в секунду
            killaura.Index = killaura.Index + 1
            if killaura.Index > math.min(#targets, killaura.MaxTargets) then
                killaura.Index = 1
            end
            killaura.LastSwitch = now
        end
        return targets[killaura.Index]
    else -- Nuker
        return GetClosestPlayerToCursor()
    end
end

-- Initialize mouse variable
local Mouse = LocalPlayer:GetMouse()

local MetaTable = getrawmetatable(game)
local OldIndex = MetaTable.__index
setreadonly(MetaTable, false)

-- Update MetaTable.__index to use GetTargetPlayer instead of GetClosestPlayerToCursor
MetaTable.__index = function(self, key)
    if not checkcaller() and self == Mouse and silentAimVars.Options.Enabled then
        if key == "Hit" or key == "Target" then
            local targetPlayer = GetTargetPlayer()
            if targetPlayer and targetPlayer.Character then
                local partName = GetTargetAimPart(targetPlayer)
                local targetPart = targetPlayer.Character:FindFirstChild(partName)
                if targetPart then
                    local finalPosition
                    if silentAimVars.Misc.Checks.Resolver.Enabled then
                        finalPosition = getPredictedPosition(targetPlayer)
                    else
                        local velocity = targetPart.Velocity or Vector3.new(0, 0, 0)
                        finalPosition = targetPart.Position + (velocity * silentAimVars.Silent.PredictionXZ)
                    end

                    if finalPosition then
                        local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                finalPosition = finalPosition + Vector3.new(0, (silentAimVars.Silent.Offsets and silentAimVars.Silent.Offsets.Jump and silentAimVars.Silent.Offsets.Jump.Amount) or 0, 0)
                            elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                finalPosition = finalPosition + Vector3.new(0, (silentAimVars.Silent.Offsets and silentAimVars.Silent.Offsets.Fall and silentAimVars.Silent.Offsets.Fall.Amount) or 0, 0)
                            end
                        end
                        return key == "Hit" and NewCFrame(finalPosition) or targetPart
                    end
                end
            end
        end
    end
    return OldIndex(self, key)
end
setreadonly(MetaTable, true)

local function FixTool(character)
    if character then
        for _, v in next, character:GetChildren() do
            if IsA(v, "Tool") then
                local currentTool = v
                currentTool.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
                break
            end
        end
    end
end

FixTool(LocalPlayer.Character)

LocalPlayer.CharacterAdded:Connect(function(character)
    FixTool(character)
end)

-- ForceHit target storage
local forceHitTarget = {
    enabled = false,
    position = Vector3.new(0, 0, 0),
    part = nil
}

-- ForceHit functionality
local function updateForceHitTarget()
    if not silentAimVars.Silent.ForceHit.Enabled then
        forceHitTarget.enabled = false
        return
    end
    
    local targetPlayer = GetTargetPlayer()
    if targetPlayer and targetPlayer.Character then
        local partName = GetTargetAimPart(targetPlayer)
        local targetPart = targetPlayer.Character:FindFirstChild(partName)
        
        if targetPart then
            forceHitTarget.enabled = true
            forceHitTarget.position = targetPart.Position
            forceHitTarget.part = targetPart
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(updateForceHitTarget)

-- Magic Bullets functionality
local lastMagicBulletTime = 0
local function updateMagicBullets()
    if not silentAimVars.Silent.MagicBullets.Enabled then return end
    
    local currentTime = tick()
    if currentTime - lastMagicBulletTime < 0.05 then return end -- 20 shots per second max
    
    local targetPlayer = GetTargetPlayer()
    if not targetPlayer or not targetPlayer.Character then return end
    
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return end
    
    local handle = tool:FindFirstChild("Handle")
    if not handle then return end
    
    local targetPart = targetPlayer.Character:FindFirstChild(silentAimVars.Silent.Part)
    local targetHead = targetPlayer.Character:FindFirstChild("Head")
    
    if targetPart and targetHead then
        game:GetService("ReplicatedStorage").MainEvent:FireServer(
            "ShootGun",
            handle,
            handle.CFrame.Position,
            targetPart.Position,
            targetHead,
            Vector3.new(0, 0, -1)
        )
        lastMagicBulletTime = currentTime
    end
end

game:GetService("RunService").Heartbeat:Connect(updateMagicBullets)

-- Hooks storage to prevent recursion
local Hooks = {}

-- Update hook for ForceHit
Hooks.Remote = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local args = { ... }
    local method = getnamecallmethod():lower()

    if forceHitTarget.enabled and forceHitTarget.position and forceHitTarget.part and 
       method == "fireserver" and self.Name == "MainEvent" and args[1] == "ShootGun" then
        args[4] = forceHitTarget.position
        args[5] = forceHitTarget.part
        args[6] = Vector3.new(0, 0, 0)
        return Hooks.Remote(self, unpack(args))
    end

    return Hooks.Remote(self, ...)
end))

-- Initialize indicator
local RunService = game:GetService("RunService")
local RND = RunService.RenderStepped

-- Destroy existing indicator if it exists
if workspace:FindFirstChild("PP") then
    workspace.PP:Destroy()
end

-- Create new indicator
local Billboard = Instance.new("BillboardGui")
Billboard.Name = "PP"
Billboard.Size = UDim2.new(1, 0, 1, 0)  -- Base size that will be scaled
Billboard.AlwaysOnTop = true
Billboard.StudsOffset = Vector3.new(0, 0, 0)
Billboard.MaxDistance = math.huge  -- No max distance limit
Billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
Billboard.ResetOnSpawn = false
Billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local img3 = Instance.new("ImageLabel")
img3.Name = "img3"
img3.Size = UDim2.new(1, 0, 1, 0)  -- Fill the entire BillboardGui
img3.Position = UDim2.new(0.5, 0, 0.5, 0)
img3.AnchorPoint = Vector2.new(0.5, 0.5)
img3.BackgroundTransparency = 1
local selected = getgenv().IndicatorConfig.Selected or "skull"
img3.Image = "rbxassetid://" .. (indicatorImages[selected] or indicatorImages["skull"])
img3.Parent = Billboard

-- Create tracking part
local adorneePart = Instance.new("Part")
adorneePart.Name = "IndicatorPart"
adorneePart.Size = Vector3.new(1, 1, 1)
adorneePart.Transparency = 1
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Parent = workspace

Billboard.Adornee = adorneePart
Billboard.Parent = workspace

-- Update indicator position
RunService.RenderStepped:Connect(function()
    local billboard = workspace:FindFirstChild("PP")
    if not billboard then return end
    
    local adorneePart = workspace:FindFirstChild("IndicatorPart")
    if not adorneePart then return end
    
    local target = GetTargetPlayer()
    if target and target.Character and getgenv().IndicatorConfig.Enabled then
        local partName = GetTargetAimPart(target)
        local targetPart = target.Character:FindFirstChild(partName)
        
        if targetPart then
            local finalPosition
            if silentAimVars.Misc.Checks.Resolver.Enabled then
                finalPosition = getPredictedPosition(target)
            else
                local velocity = targetPart.Velocity or Vector3.new(0, 0, 0)
                finalPosition = targetPart.Position + (velocity * silentAimVars.Silent.PredictionXZ)
            end

            if finalPosition then
                -- Calculate scale based on distance
                local camPos = Camera.CFrame.Position
                local dist = (camPos - finalPosition).Magnitude
                local scale = math.clamp(dist/100, 1.5, 4.5)
                
                adorneePart.Position = finalPosition
                billboard.Size = UDim2.new(scale, 0, scale, 0)
                billboard.Enabled = true
                return
            end
        end
    end
    
    adorneePart.Position = Vector3.new(0, 0, 0)
    billboard.Enabled = false
end)

-- Hit detection logic for visual effects
local RND = game:GetService("RunService").RenderStepped

-- Hit sound function
local function PlayHitSound(hitsounds, config, SoundService)
    if config.Enabled and config.Selected and hitsounds[config.Selected] then
        local sound = Instance.new("Sound")
        sound.SoundId = hitsounds[config.Selected]
        sound.Volume = config.Volume or 0.5
        sound.PlaybackSpeed = config.Pitch or 1.0
        sound.Parent = SoundService
        sound:Play()
        sound.Ended:Connect(function()
            sound:Destroy()
        end)
    end
end

-- Реализация функции HitChams
local TweenService = game:GetService("TweenService")
function HitChams(Player, Config)
    if not (Config and Config.Enabled) then return end
    if Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
        Player.Character.Archivable = true
        local Cloned = Player.Character:Clone()
        Cloned.Name = "Player Clone"
        local BodyParts = {
            "Head", "UpperTorso", "LowerTorso",
            "LeftUpperArm", "LeftLowerArm", "LeftHand",
            "RightUpperArm", "RightLowerArm", "RightHand",
            "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
            "RightUpperLeg", "RightLowerLeg", "RightFoot"
        }
        for _, Part in ipairs(Cloned:GetChildren()) do
            if Part:IsA("BasePart") then
                local PartValid = false
                for _, validPart in ipairs(BodyParts) do
                    if Part.Name == validPart then
                        PartValid = true
                        break
                    end
                end
                if not PartValid then
                    Part:Destroy()
                end
            elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
                Part:Destroy()
            end
        end
        if Cloned:FindFirstChild("Humanoid") then
            Cloned.Humanoid:Destroy()
        end
        for _, BodyPart in ipairs(Cloned:GetChildren()) do
            if BodyPart:IsA("BasePart") then
                BodyPart.CanCollide = false
                BodyPart.Anchored = true
                BodyPart.Transparency = Config.Transparency
                BodyPart.Color = Config.Color
                BodyPart.Material = Config.Material
            end
        end
        if Cloned:FindFirstChild("Head") then
            local Head = Cloned.Head
            Head.Transparency = Config.Transparency
            Head.Color = Config.Color
            Head.Material = Config.Material
            if Head:FindFirstChild("face") then
                Head.face:Destroy()
            end
        end
        Cloned.Parent = game.Workspace
        local tweenInfo = TweenInfo.new(
            Config.Duration,
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.InOut,
            0,
            false
        )
        for _, BodyPart in ipairs(Cloned:GetChildren()) do
            if BodyPart:IsA("BasePart") then
                local tween = TweenService:Create(BodyPart, tweenInfo, { Transparency = 1 })
                tween:Play()
            end
        end
        task.delay(Config.Duration, function()
            if Cloned and Cloned.Parent then
                Cloned:Destroy()
            end
        end)
    end
end

-- Track target HP changes for hit effects
local lastTarget, lastHP
RND:Connect(function()
    local hitConfig = getgenv().HitSoundsConfig
    local chamsConfig = getgenv().HitChamsConfig
    local SoundService = game:GetService("SoundService")
    
    if not (chamsConfig and chamsConfig.Enabled) and not (hitConfig and hitConfig.Enabled) then
        lastTarget, lastHP = nil, nil
        return
    end
    
    local silentAim = getgenv().SilentAim
    local target = silentAim and (silentAim.currentTarget or GetTargetPlayer())
    
    if not target then 
        return 
    end
    
    if not target.Character then
        return
    end
    
    local humanoid = target.Character:FindFirstChild('Humanoid')
    if not humanoid then
        return
    end
    
    -- Теперь мы знаем что и Character и Humanoid существуют
    if target and target.Character and humanoid then
        local hum = target.Character.Humanoid
        local hp = nil
        local success, err = pcall(function()
            hp = hum.Health
        end)
        if not success then
            lastTarget, lastHP = nil, nil
            return
        end
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else
            if hp < lastHP then
                local damageDealt = lastHP - hp
                local selectedPart = GetTargetAimPart(target)
                -- Play hit sound
                PlayHitSound(hitsoundsList, hitConfig, SoundService)
                -- Apply hit chams
                if chamsConfig and chamsConfig.Enabled then
                    HitChams(target, chamsConfig)
                end
                -- Show damage notification (if we add UI Library later)
                if window and window.CreateNotification then
                    local damageText = string.format("%d", damageDealt)
                    local remainingValue = string.format("%d", math.max(hp, 0))
                    window:CreateNotification({
                        Title = "Hit",
                        Content = string.format("Hit %s on %s for %s (%s remaining)", 
                            target.DisplayName or target.Name,
                            selectedPart,
                            damageText,
                            remainingValue
                        ),
                        Duration = 1.5
                    })
                end
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
    end
end)

getgenv().Loaded = true

