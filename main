
-- Load optimization variables table
local variablesURL = 'https://raw.githubusercontent.com/xzcReasd/IDKWHATTOSAY/refs/heads/main/Var'
local variables = loadstring(game:HttpGet(variablesURL))()

-- Load ImGui library
local SourceURL = 'https://raw.githubusercontent.com/xzcReasd/IDKWHATTOSAY/refs/heads/main/Source'
ImGui = loadstring(game:HttpGet(SourceURL))()

-- Sound management functions
local downloadSound = (function(SoundName, SoundUrl)
    local SoundPath = string.format("sounds/%s", SoundName)
    if not isfile(SoundPath) then
        writefile(SoundPath, game:HttpGet(SoundUrl))
    end
    return SoundPath
end)

local function getAsset(filename)
    if isfile("sounds/" .. filename) then
        return getcustomasset("sounds/" .. filename)
    end
    return nil
end

-- Create sounds directory if it doesn't exist
if not isfolder("sounds") then
    makefolder("sounds")
end

-- Download custom sounds
local sounds = {
    BlackPencil = "https://github.com/Shatapmatehabibi/Hitsounds/raw/main/bananapencil.mp3.mp3",
    UWU = "https://github.com/CongoOhioDog/SoundS/blob/main/Uwu.mp3?raw=true",
    Plooh = "https://github.com/CongoOhioDog/SoundS/blob/main/plooh.mp3?raw=true",
    Hrntai = "https://github.com/CongoOhioDog/SoundS/blob/main/Hrntai.wav?raw=true",
    Henta01 = "https://github.com/CongoOhioDog/SoundS/blob/main/henta01.wav?raw=true",
    Bruh = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20bruh%20sample.mp3?raw=true",
    BoneBreakage = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20bone%20breakage.mp3?raw=true",
    Fein = "https://github.com/CongoOhioDog/SoundS/blob/main/psalms%20highly%20defined%20fein.mp3?raw=true",
    Unicorn = "https://github.com/CongoOhioDog/SoundS/blob/main/shiny%20unicorn%20for%20dh%20_%20psalms.mp3?raw=true",
    Kitty = "https://github.com/CongoOhioDog/SoundS/blob/main/Kitty.mp3?raw=true",
    Bird = "https://github.com/CongoOhioDog/SoundS/blob/main/bird%20chirping%20for%20DH%20_%20psalms%20audio.mp3?raw=true",
    BirthdayCake = "https://github.com/CongoOhioDog/SoundS/blob/main/Birthday%20cake%20for%20dh%20_%20psalms.mp3?raw=true", 
    KenCarson = "https://github.com/CongoOhioDog/SoundS/blob/main/ken_carson_-_jennifer_s_body_offici(2).mp3?raw=true"
}

-- Download all sounds
for name, url in pairs(sounds) do
    _G[name .. "Path"] = downloadSound(name .. ".mp3", url)
end

-- Initialize Silent Aim variables first
local silentAimVars = variables and variables.SilentAim or getgenv().SilentAim
if not silentAimVars then
    silentAimVars = {
        Options = { Enabled = false },
        Silent = { 
            PredictionXZ = 0.12362, 
            PredictionY = 0.12362, 
            Part = "HumanoidRootPart",
            ForceHit = {
                Enabled = false,
                State = true
            },
            MagicBullets = {
                Enabled = false
            }
        },
        Misc = { 
            Checks = { 
                Resolver = { Enabled = false, Type = "Calculate CFrame" },
                WallCheck = { Enabled = false },
                KOCheck = { Enabled = false },
                SitCheck = { Enabled = false },
                GrabCheck = { Enabled = false }
            },
            TargetMode = "Nuker",
            StickyTarget = {
                Enabled = false,
                Key = Enum.KeyCode.X,
                Target = nil
            },
            KillAura = {
                MaxTargets = 3,
                Index = 1,
                LastSwitch = 0
            }
        }
    }
    getgenv().SilentAim = silentAimVars
end

-- Initialize configs
if not getgenv().HitSoundsConfig then
    getgenv().HitSoundsConfig = {
        Enabled = false,
        Selected = "RIFK7",
        Volume = 0.5,
        Pitch = 1.0
    }
end

if not getgenv().HitChamsConfig then
    getgenv().HitChamsConfig = {
        Enabled = false,
        Transparency = 0.5,
        Duration = 1.0,
        Color = Color3.fromRGB(255, 0, 0),
        Material = Enum.Material.ForceField
    }
end

if not getgenv().IndicatorConfig then
    getgenv().IndicatorConfig = {
        Enabled = false,
        Selected = "skull",
        Size = 2,
        Transparency = 0.5
    }
end

if not getgenv().HighlightTargetConfig then
    getgenv().HighlightTargetConfig = {
        Enabled = false,
        Transparency1 = 0.5,
        Transparency2 = 0.3,
        Color1 = {
            R = 255,
            G = 0,
            B = 0
        },
        Color2 = {
            R = 0,
            G = 255,
            B = 0
        }
    }
end

if not getgenv().TracerToTargetConfig then
    getgenv().TracerToTargetConfig = {
        Enabled = false,
        Thickness = 2,
        Color = {
            R = 255,
            G = 255,
            B = 255
        }
    }
end

-- Speedhack Configuration
if not getgenv().SpeedhackConfig then
    getgenv().SpeedhackConfig = {
        Enabled = false,
        Active = false,
        Speed = 50,
        Keybind = Enum.KeyCode.X
    }
end

-- FlyHack Configuration
if not getgenv().FlyConfig then
    getgenv().FlyConfig = {
        Enabled = false,
        Active = false,
        Speed = 1,
        Keybind = Enum.KeyCode.F
    }
end

-- Define available indicator images
local indicatorImages = {
    ["skull"] = "108770683919433",
    ["trollface"] = "130642148173502"
}

-- Speedhack Logic
local S = {
    PS = game:GetService('Players'),
    RS = game:GetService('RunService'),
    UIS = game:GetService('UserInputService'),
}
local HRT = S.RS.Heartbeat
local LP = S.PS.LocalPlayer
local M = math

local speedHackConnection

local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild('HumanoidRootPart')
    local humanoid = character:WaitForChild('Humanoid')
    if speedHackConnection then speedHackConnection:Disconnect() end
    speedHackConnection = HRT:Connect(function(dt)
        if getgenv().SpeedhackConfig.Enabled and getgenv().SpeedhackConfig.Active then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                rootPart.CFrame = rootPart.CFrame + (move.Unit * getgenv().SpeedhackConfig.Speed * dt)
            end
        end
    end)
end

-- Speedhack functions
getgenv().EnableSpeedhack = function()
    getgenv().SpeedhackConfig.Enabled = true
    updateSpeedHack(LP.Character)
end

getgenv().DisableSpeedhack = function()
    getgenv().SpeedhackConfig.Enabled = false
    getgenv().SpeedhackConfig.Active = false
    if speedHackConnection then speedHackConnection:Disconnect() speedHackConnection = nil end
end

getgenv().ToggleSpeedhackKey = function()
    if not getgenv().SpeedhackConfig.Enabled then return end
    getgenv().SpeedhackConfig.Active = not getgenv().SpeedhackConfig.Active
end

getgenv().SetSpeedhackSpeed = function(val)
    local num = tonumber(val)
    if num then
        num = math.clamp(num, 1, 2000000)
        getgenv().SpeedhackConfig.Speed = num
    end
end

-- Character respawn handler for speedhack
LP.CharacterAdded:Connect(function(char)
    if getgenv().SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
end)

-- FlyHack Logic
local SND = S.RS.Stepped
local Cam = workspace.CurrentCamera
local FlyLoop = nil

local function setNoClip(character, state)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end

local function updateFly(character)
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    if not character then return end
    if not (getgenv().FlyConfig.Enabled and getgenv().FlyConfig.Active) then return end
    setNoClip(character, true)
    FlyLoop = SND:Connect(function()
        local char = LP.Character
        if not char then return end
        setNoClip(char, true)
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if not hrp or not hum then return end
        local speed = getgenv().FlyConfig.Speed * 50
        local velocity = Vector3.new(0, 0, 0)
        if S.UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + Vector3.new(0, speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + Vector3.new(0, -speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (Cam.CFrame.LookVector * speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (Cam.CFrame.RightVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (Cam.CFrame.LookVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (Cam.CFrame.RightVector * speed) end
        hrp.Velocity = velocity
        hum:ChangeState('Freefall')
    end)
end

local function stopFly()
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    local char = LP.Character
    setNoClip(char, false)
    if char then
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if hrp then
            hrp.Velocity = Vector3.new(0, -2, 0)
            local tempConn
            tempConn = SND:Connect(function()
                if not hrp or not hrp.Parent then tempConn:Disconnect() return end
                hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
                tempConn:Disconnect()
            end)
        end
        if hum then hum:ChangeState('Landing') end
    end
end

-- FlyHack functions
getgenv().EnableFly = function()
    getgenv().FlyConfig.Enabled = true
    if getgenv().FlyConfig.Active then
        updateFly(LP.Character)
    end
end

getgenv().DisableFly = function()
    getgenv().FlyConfig.Enabled = false
    getgenv().FlyConfig.Active = false
    stopFly()
end

getgenv().ToggleFlyKey = function()
    if not getgenv().FlyConfig.Enabled then return end
    getgenv().FlyConfig.Active = not getgenv().FlyConfig.Active
    if getgenv().FlyConfig.Active then
        updateFly(LP.Character)
    else
        stopFly()
    end
end

getgenv().SetFlySpeed = function(val)
    local num = tonumber(val)
    if num then
        num = math.clamp(num, 0.1, 100)
        getgenv().FlyConfig.Speed = num
    end
end

-- Character respawn handler for flyhack
LP.CharacterAdded:Connect(function(char)
    if getgenv().FlyConfig.Enabled and getgenv().FlyConfig.Active then
        updateFly(char)
    end
end)

-- Create main window
local window = ImGui:CreateWindow({
    Title = "Freedom.TAPBOT",
    Size = UDim2.new(0, 900, 0, 600),
})

window:Center()

-- Create tabs
local tabRage = window:CreateTab({
    Name = "RAGE"
})

local tabMisc = window:CreateTab({
    Name = "MISC"
})

-- Add speedhack section to MISC tab
local speedhackHeader = tabMisc:CollapsingHeader({
    Title = "speedhack"
})

-- Speedhack toggle
speedhackHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().SpeedhackConfig.Enabled,
    Callback = function(self, value)
        getgenv().SpeedhackConfig.Enabled = value
        if value then
            getgenv().EnableSpeedhack()
        else
            getgenv().DisableSpeedhack()
        end
    end
})

-- Speedhack keybind
speedhackHeader:Keybind({
    Label = "Keybind",
    Value = getgenv().SpeedhackConfig.Keybind,
    Callback = function(self, value)
        getgenv().SpeedhackConfig.Keybind = value
    end
})

-- Speedhack speed input
speedhackHeader:InputText({
    Label = "Speed",
    Value = tostring(getgenv().SpeedhackConfig.Speed),
    PlaceHolder = "Enter speed value",
    Callback = function(self, value)
        getgenv().SetSpeedhackSpeed(value)
    end
})

-- Add FlyHack section to MISC tab
local flyhackHeader = tabMisc:CollapsingHeader({
    Title = "FlyHack"
})

-- FlyHack toggle
flyhackHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().FlyConfig.Enabled,
    Callback = function(self, value)
        getgenv().FlyConfig.Enabled = value
        if value then
            getgenv().EnableFly()
        else
            getgenv().DisableFly()
        end
    end
})

-- FlyHack keybind
flyhackHeader:Keybind({
    Label = "Keybind",
    Value = getgenv().FlyConfig.Keybind,
    Callback = function(self, value)
        getgenv().FlyConfig.Keybind = value
    end
})

-- FlyHack speed input
flyhackHeader:InputText({
    Label = "Speed",
    Value = tostring(getgenv().FlyConfig.Speed),
    PlaceHolder = "Enter speed multiplier (0.1-100)",
    Callback = function(self, value)
        getgenv().SetFlySpeed(value)
    end
})

local rageHeader = tabRage:CollapsingHeader({
    Title = "ragebot"
})

-- Add visual section
local visualHeader = tabRage:CollapsingHeader({
    Title = "visual"
})

-- Add hitsounds section inside visual
local hitsoundsHeader = visualHeader:CollapsingHeader({
    Title = "hitsounds"
})

-- Добавить секцию HitChams в visual
local hitchamsHeader = visualHeader:CollapsingHeader({
    Title = "hitchams"
})

-- HitChams section (labels на английском)
hitchamsHeader:Checkbox({
    Label = "Enable HitChams",
    Value = getgenv().HitChamsConfig.Enabled,
    Callback = function(self, value)
        getgenv().HitChamsConfig.Enabled = value
    end
})

hitchamsHeader:Slider({
    Label = "Transparency",
    Value = getgenv().HitChamsConfig.Transparency,
    MinValue = 0,
    MaxValue = 1,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitChamsConfig.Transparency = value
        return true
    end
})

hitchamsHeader:Slider({
    Label = "Duration",
    Value = getgenv().HitChamsConfig.Duration,
    MinValue = 0.1,
    MaxValue = 5,
    Step = 0.1,
    Format = "%.1f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitChamsConfig.Duration = value
        return true
    end
})

hitchamsHeader:Combo({
    Label = "Material",
    Items = {"ForceField", "Neon", "Plastic", "SmoothPlastic", "Glass"},
    Placeholder = tostring(getgenv().HitChamsConfig.Material.Name),
    Callback = function(self, value)
        getgenv().HitChamsConfig.Material = Enum.Material[value]
    end
})

-- Новый CollapsingHeader для выбора цвета через слайдеры
local colorHeader = hitchamsHeader:CollapsingHeader({
    Title = "Color"
})

-- Получаем текущие значения R, G, B
local function getRGB()
    local color = getgenv().HitChamsConfig.Color
    return math.floor(color.R * 255), math.floor(color.G * 255), math.floor(color.B * 255)
end

local r, g, b = getRGB()

colorHeader:Slider({
    Label = "R",
    Value = r,
    MinValue = 1,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        local _, g, b = getRGB()
        getgenv().HitChamsConfig.Color = Color3.fromRGB(value, g, b)
        return true
    end
})
colorHeader:Slider({
    Label = "G",
    Value = g,
    MinValue = 1,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local r, _, b = getRGB()
        local value = self:GetValue()
        getgenv().HitChamsConfig.Color = Color3.fromRGB(r, value, b)
        return true
    end
})
colorHeader:Slider({
    Label = "B",
    Value = b,
    MinValue = 1,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local r, g, _ = getRGB()
        local value = self:GetValue()
        getgenv().HitChamsConfig.Color = Color3.fromRGB(r, g, value)
        return true
    end
})

-- Add indicator section inside visual
local indicatorHeader = visualHeader:CollapsingHeader({
    Title = "indicator"
})

-- Add indicator controls
indicatorHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().IndicatorConfig.Enabled,
    Callback = function(self, value)
        getgenv().IndicatorConfig.Enabled = value
    end
})

indicatorHeader:Combo({
    Label = "Image",
    Items = {"skull", "trollface"},
    Placeholder = getgenv().IndicatorConfig.Selected or "skull",
    Callback = function(self, value)
        getgenv().IndicatorConfig.Selected = value
        local billboard = workspace:FindFirstChild("PP")
        if billboard and billboard:FindFirstChild("img3") then
            local selected = value or "skull"
            billboard.img3.Image = "rbxassetid://" .. (indicatorImages[selected] or indicatorImages["skull"])
        end
    end
})

-- Add Highlight target section inside visual
local highlightTargetHeader = visualHeader:CollapsingHeader({
    Title = "Highlight target"
})

-- Highlight target toggle
highlightTargetHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().HighlightTargetConfig.Enabled,
    Callback = function(self, value)
        getgenv().HighlightTargetConfig.Enabled = value
    end
})

-- Transparency sliders
highlightTargetHeader:Slider({
    Label = "Transparency 1",
    Value = getgenv().HighlightTargetConfig.Transparency1,
    MinValue = 0,
    MaxValue = 1,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Transparency1 = value
        return true
    end
})

highlightTargetHeader:Slider({
    Label = "Transparency 2",
    Value = getgenv().HighlightTargetConfig.Transparency2,
    MinValue = 0,
    MaxValue = 1,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Transparency2 = value
        return true
    end
})

-- Color 1 header with RGB sliders
local color1Header = highlightTargetHeader:CollapsingHeader({
    Title = "Color 1"
})

color1Header:Slider({
    Label = "R",
    Value = getgenv().HighlightTargetConfig.Color1.R,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color1.R = value
        return true
    end
})

color1Header:Slider({
    Label = "G",
    Value = getgenv().HighlightTargetConfig.Color1.G,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color1.G = value
        return true
    end
})

color1Header:Slider({
    Label = "B",
    Value = getgenv().HighlightTargetConfig.Color1.B,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color1.B = value
        return true
    end
})

-- Color 2 header with RGB sliders
local color2Header = highlightTargetHeader:CollapsingHeader({
    Title = "Color 2"
})

color2Header:Slider({
    Label = "R",
    Value = getgenv().HighlightTargetConfig.Color2.R,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color2.R = value
        return true
    end
})

color2Header:Slider({
    Label = "G",
    Value = getgenv().HighlightTargetConfig.Color2.G,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color2.G = value
        return true
    end
})

color2Header:Slider({
    Label = "B",
    Value = getgenv().HighlightTargetConfig.Color2.B,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HighlightTargetConfig.Color2.B = value
        return true
    end
})

-- Combine and deduplicate hitsounds
local hitsoundsList = {
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bubble"] = "rbxassetid://9102092728",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Cod"] = "rbxassetid://160432334",
    ["Bameware"] = "rbxassetid://6565367558",
    ["Neverlose"] = "rbxassetid://6565370984",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Rust"] = "rbxassetid://6565371338",
    ["BlackPencil"] = getAsset("BlackPencil.mp3"),
    ["UWU"] = getAsset("Uwu.mp3"),
    ["Plooh"] = getAsset("plooh.mp3"),
    ["Moan"] = getAsset("Hrntai.mp3"),
    ["Hentai"] = getAsset("Henta01.mp3"),
    ["Bruh"] = getAsset("Bruh.mp3"),
    ["BoneBreakage"] = getAsset("BoneBreakage.mp3"),
    ["Fein"] = getAsset("Fein.mp3"),
    ["Unicorn"] = getAsset("Unicorn.mp3"),
    ["Kitty"] = getAsset("Kitty.mp3"),
    ["Bird"] = getAsset("Bird.mp3"),
    ["BirthdayCake"] = getAsset("BirthdayCake.mp3"),
    ["KenCarson"] = getAsset("KenCarson.mp3")
}

-- Create array of sound names for Combo
local soundNames = {}
for name, _ in pairs(hitsoundsList) do
    table.insert(soundNames, name)
end
table.sort(soundNames) -- Sort alphabetically

-- Add hitsound controls
hitsoundsHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().HitSoundsConfig.Enabled,
    Callback = function(self, value)
        getgenv().HitSoundsConfig.Enabled = value
    end
})

hitsoundsHeader:Combo({
    Label = "Sound",
    Items = soundNames,
    Placeholder = getgenv().HitSoundsConfig.Selected,
    Callback = function(self, value)
        getgenv().HitSoundsConfig.Selected = value
    end
})

hitsoundsHeader:Slider({
    Label = "Volume",
    Value = HitSoundsConfig.Volume,
    MinValue = 1,
    MaxValue = 3,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitSoundsConfig.Volume = value
        return true
    end
})

hitsoundsHeader:Slider({
    Label = "Pitch",
    Value = HitSoundsConfig.Pitch,
    MinValue = 0.1,
    MaxValue = 3,
    Step = 0.01,
    Format = "%.2f",
    Callback = function(self)
        local value = self:GetValue()
        getgenv().HitSoundsConfig.Pitch = value
        return true
    end
})

-- Add TracerToTarget section inside visual
local tracerToTargetHeader = visualHeader:CollapsingHeader({
    Title = "TracerToTarget"
})

-- TracerToTarget enable checkbox
tracerToTargetHeader:Checkbox({
    Label = "Enable",
    Value = getgenv().TracerToTargetConfig.Enabled,
    Callback = function(self, value)
        getgenv().TracerToTargetConfig.Enabled = value
    end
})

-- TracerToTarget thickness slider
tracerToTargetHeader:Slider({
    Label = "Thickness",
    Value = getgenv().TracerToTargetConfig.Thickness,
    MinValue = 1,
    MaxValue = 10,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().TracerToTargetConfig.Thickness = value
        return true
    end
})

-- TracerToTarget color header with RGB sliders
local tracerColorHeader = tracerToTargetHeader:CollapsingHeader({
    Title = "Color"
})

tracerColorHeader:Slider({
    Label = "R",
    Value = getgenv().TracerToTargetConfig.Color.R,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().TracerToTargetConfig.Color.R = value
        return true
    end
})

tracerColorHeader:Slider({
    Label = "G",
    Value = getgenv().TracerToTargetConfig.Color.G,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().TracerToTargetConfig.Color.G = value
        return true
    end
})

tracerColorHeader:Slider({
    Label = "B",
    Value = getgenv().TracerToTargetConfig.Color.B,
    MinValue = 0,
    MaxValue = 255,
    Step = 1,
    Callback = function(self)
        local value = self:GetValue()
        getgenv().TracerToTargetConfig.Color.B = value
        return true
    end
})

-- Create other tabs
local tabMisc = window:CreateTab({ Name = "MISC" })
local tabVisual = window:CreateTab({ Name = "VISUAL" })
local tabPlayer = window:CreateTab({ Name = "PLAYER" })
local tabConfig = window:CreateTab({ Name = "CONFIG" })

-- Silent Aim CollapsingHeader
if silentAimVars and silentAimVars.Options then
    silentAimVars.Options.Enabled = false
    if silentAimVars.Misc and silentAimVars.Misc.Checks and silentAimVars.Misc.Checks.Resolver then
        silentAimVars.Misc.Checks.Resolver.Enabled = false
    end
    if not silentAimVars.Misc.KillAura then
        silentAimVars.Misc.KillAura = { MaxTargets = 3, Index = 1, LastSwitch = 0 }
    end
end

local resolverTypes = { "None", "Calculate CFrame", "Move direction", "Velocity" }
local targetModes = { "Nuker", "Sticky", "KillAura" }

local aimPartsList = {"HumanoidRootPart", "Head", "UpperTorso", "LowerTorso", "LeftFoot", "RightFoot", "LeftHand", "RightHand"}

if not silentAimVars.Silent.AirPart then
    silentAimVars.Silent.AirPart = "Head"
end
if not silentAimVars.Silent.Part then
    silentAimVars.Silent.Part = "HumanoidRootPart"
end




rageHeader:Checkbox({
    Label = "Enable",
    Value = silentAimVars.Options.Enabled,
    Callback = function(self, value)
        silentAimVars.Options.Enabled = value
    end
})

rageHeader:Checkbox({
    Label = "ForceHit",
    Value = silentAimVars.Silent.ForceHit.Enabled,
    Callback = function(self, value)
        silentAimVars.Silent.ForceHit.Enabled = value
        silentAimVars.Silent.ForceHit.State = true
    end
})

rageHeader:Checkbox({
    Label = "MagicBullets",
    Value = silentAimVars.Silent.MagicBullets.Enabled,
    Callback = function(self, value)
        silentAimVars.Silent.MagicBullets.Enabled = value
    end
})

rageHeader:InputText({
    Label = "PredXZ",
    Value = tostring(silentAimVars.Silent.PredictionXZ),
    PlaceHolder = "Enter Prediction XZ",
    Callback = function(self, value)
        local num = tonumber(value)
        if num then
            silentAimVars.Silent.PredictionXZ = num
        end
    end
})

rageHeader:InputText({
    Label = "PredY",
    Value = tostring(silentAimVars.Silent.PredictionY),
    PlaceHolder = "Enter Prediction Y",
    Callback = function(self, value)
        local num = tonumber(value)
        if num then
            silentAimVars.Silent.PredictionY = num
        end
    end
})

rageHeader:Combo({
    Label = "Resolver",
    Items = resolverTypes,
    Placeholder = silentAimVars.Misc.Checks.Resolver.Type or "None",
    Callback = function(self, value)
        if value == "None" then
            silentAimVars.Misc.Checks.Resolver.Enabled = false
        else
            silentAimVars.Misc.Checks.Resolver.Enabled = true
            silentAimVars.Misc.Checks.Resolver.Type = value
        end
    end
})

-- Target Mode Selection
rageHeader:Combo({
    Label = "SelectTargetMode",
    Items = targetModes,
    Placeholder = silentAimVars.Misc.TargetMode,
    Callback = function(self, value)
        silentAimVars.Misc.TargetMode = value
        if value == "Nuker" then
            silentAimVars.Misc.StickyTarget.Target = nil
        end
    end
})

-- Sticky Target Keybind
rageHeader:Keybind({
    Label = "StickyKey",
    Value = silentAimVars.Misc.StickyTarget.Key,
    Callback = function(self, value)
        silentAimVars.Misc.StickyTarget.Key = value
    end
})

rageHeader:Slider({
    Label = "KillAuraTargets",
    Value = silentAimVars.Misc.KillAura.MaxTargets,
    MinValue = 1,
    MaxValue = 10,
    Callback = function(self, value)
        silentAimVars.Misc.KillAura.MaxTargets = math.floor(value)
    end
})

-- Checks Header
local checksHeader = rageHeader:CollapsingHeader({
    Title = "Checks",
    Open = false
})

checksHeader:Checkbox({
    Label = "Wall",
    Value = silentAimVars.Misc.Checks.WallCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.WallCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Knocked",
    Value = silentAimVars.Misc.Checks.KOCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.KOCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Seat",
    Value = silentAimVars.Misc.Checks.SitCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.SitCheck.Enabled = value
    end
})

checksHeader:Checkbox({
    Label = "Grabbed",
    Value = silentAimVars.Misc.Checks.GrabCheck.Enabled,
    Callback = function(self, value)
        silentAimVars.Misc.Checks.GrabCheck.Enabled = value
    end
})

-- ORBIT CONFIG
getgenv().anarchy = getgenv().anarchy or {}
getgenv().anarchy['orbit'] = getgenv().anarchy['orbit'] or {
    Enabled = false,
    Keybind = Enum.KeyCode.Q,
    Speed = 15,
    Height = 15,
    Radius = 15
}
local orbitConfig = getgenv().anarchy['orbit']

local orbitHeader = rageHeader:CollapsingHeader({
    Title = "Orbit"
})

orbitHeader:Checkbox({
    Label = "Enable Orbit",
    Value = orbitConfig.Enabled,
    Callback = function(self, value)
        orbitConfig.Enabled = value
        if not value then
            TargTp = false
            TargPlr = nil
        end
    end
})

orbitHeader:Keybind({
    Label = "Keybind",
    Value = orbitConfig.Keybind,
    Callback = function(self, value)
        orbitConfig.Keybind = value
    end
})
orbitHeader:Slider({
    Label = "Speed",
    Value = orbitConfig.Speed,
    MinValue = 1,
    MaxValue = 50,
    Step = 1,
    Callback = function(self)
        orbitConfig.Speed = self:GetValue()
        return true
    end
})
orbitHeader:Slider({
    Label = "Height",
    Value = orbitConfig.Height,
    MinValue = 0,
    MaxValue = 50,
    Step = 1,
    Callback = function(self)
        orbitConfig.Height = self:GetValue()
        return true
    end
})
orbitHeader:Slider({
    Label = "Radius",
    Value = orbitConfig.Radius,
    MinValue = 1,
    MaxValue = 50,
    Step = 1,
    Callback = function(self)
        orbitConfig.Radius = self:GetValue()
        return true
    end
})

-- ORBIT LOGIC
local LocalPlr = game.Players.LocalPlayer
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
TargPlr = nil
TargTp = false

local function GetClosestPlayer2()
    local Distance, Player = math.huge, nil
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlr and v ~= nil then
            local Character = v.Character
            local RootPart = Character and Character:FindFirstChild('HumanoidRootPart')
            if RootPart then
                local Position, OnScreen = Camera:WorldToViewportPoint(RootPart.Position)
                local Magnitude = (Vector2.new(Position.X, Position.Y) - UserInputService:GetMouseLocation()).Magnitude
                if Magnitude <= Distance and OnScreen then
                    Distance = Magnitude
                    Player = v
                end
            end
        end
    end
    return Player
end

local function updateNetworkedPosition()
    if not orbitConfig.Enabled then return end
    if TargTp then
        -- Простая проверка цели (без GetCurrentTarget чтобы избежать ошибок порядка)
        if TargPlr and TargPlr.Character and TargPlr.Character:FindFirstChild("HumanoidRootPart") then
            local RootPart = LocalPlr.Character and LocalPlr.Character:FindFirstChild("HumanoidRootPart")
            if not RootPart then return end
            
            local realPosition = RootPart.Position
            local realVelocity = RootPart.AssemblyLinearVelocity
            local time = tick() * orbitConfig.Speed
            local radius = orbitConfig.Radius
            local height = orbitConfig.Height
            local offsetX = math.cos(time) * radius
            local offsetZ = math.sin(time) * radius
            local offsetY = 0
            
            local targetCFrame = TargPlr.Character.HumanoidRootPart.CFrame
            local center = targetCFrame.Position + Vector3.new(0, height, 0)
            RootPart.CFrame = CFrame.new(center + Vector3.new(offsetX, offsetY, offsetZ), center)
            RootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            task.wait()
            RootPart.CFrame = CFrame.new(realPosition)
            RootPart.AssemblyLinearVelocity = realVelocity
        else
            -- Нет валидной цели - отключаем орбит
            TargTp = false
            TargPlr = nil
            print("[ORBIT] Орбит отключен - нет валидной цели")
        end
    end
end

-- Orbit keybind handler будет добавлен после определения GetTargetPlayer()

RunService.Heartbeat:Connect(updateNetworkedPosition)

-- ВНЕДРЕНИЕ САМОГО АИМБОТА (Silent Aim)
local SilentAim = getgenv().SilentAim
if getgenv().Loaded then return end

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local FindFirstChild = game.FindFirstChild
local FindPartOnRayWithIgnoreList = Workspace.FindPartOnRayWithIgnoreList
local GetPlayers = Players.GetPlayers
local GetMouseLocation = UserInputService.GetMouseLocation
local WorldToViewportPoint = Camera.WorldToViewportPoint
local NewVector2 = Vector2.new
local NewCFrame = CFrame.new
local NewRay = Ray.new
local TableFind = table.find
local IsA = game.IsA
local Inf = math.huge

local function IsPlayerAlive(player)
    return player and player.Character and FindFirstChild(player.Character, "Humanoid") and player.Character.Humanoid.Health > 0
end

local function BehindWall(character)
    local targetPosition = character.HumanoidRootPart.Position
    local cameraPosition = Camera.CFrame.Position
    local distance = (targetPosition - cameraPosition).Magnitude
    local hitPart, hitPosition = FindPartOnRayWithIgnoreList(
        Workspace,
        NewRay(cameraPosition, (targetPosition - cameraPosition).Unit * distance),
        { LocalPlayer.Character, character }
    )
    return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

local function isPlayerKO(player)
    if not player.Character then
        return false
    end
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if bodyEffects then
        local KO = bodyEffects:FindFirstChild("K.O")
        if KO and KO:IsA("BoolValue") and KO.Value then
            return true
        end
    end
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart and humanoidRootPart.Anchored then
        return true
    end
    return false
end

local function isPlayerSeated(player)
    if not player.Character then
        return false
    end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.SeatPart then
        return true
    end
    return false
end

local function isPlayerGrabbed(player)
    if not player or not player.Character then return false end
    return player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
end

local function WallCheck(character)
    if not SilentAim.Misc.Checks.WallCheck.Enabled then
        return true
    end
    if not character then return false end
    return not BehindWall(Players:GetPlayerFromCharacter(character))
end

local function PassesChecks(player)
    if not player or not player.Character then return false end
    
    if not IsPlayerAlive(player) then return false end
    
    if SilentAim.Misc.Checks.KOCheck.Enabled and isPlayerKO(player) then return false end
    if SilentAim.Misc.Checks.SitCheck.Enabled and isPlayerSeated(player) then return false end
    if SilentAim.Misc.Checks.GrabCheck.Enabled and isPlayerGrabbed(player) then return false end
    
    return true
end

-- Resolver Variables
local lastPosition = nil
local lastUpdateTime = nil
local predictedPosition = nil

local function getPredictedPosition(targetPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
        local aimPartPos = targetPlayer.Character[silentAimVars.Silent.Part].Position

        if not lastPosition or not lastUpdateTime then
            lastPosition = aimPartPos
            lastUpdateTime = tick()
            predictedPosition = aimPartPos
            return predictedPosition
        end

        local currentTime = tick()
        local deltaTime = currentTime - lastUpdateTime

        local predictionResolver = silentAimVars.Misc.Checks.Resolver.Type
        if predictionResolver == "Velocity" then
            local velocity = targetPlayer.Character[silentAimVars.Silent.Part].Velocity
            predictedPosition = aimPartPos + Vector3.new(
                velocity.X * silentAimVars.Silent.PredictionXZ,
                velocity.Y * silentAimVars.Silent.PredictionY,
                velocity.Z * silentAimVars.Silent.PredictionXZ
            )
        elseif predictionResolver == "Move direction" then
            predictedPosition = aimPartPos + (targetPlayer.Character.Humanoid.MoveDirection * (silentAimVars.Silent.PredictionXZ * 10))
        elseif predictionResolver == "Calculate CFrame" then
            if (aimPartPos - lastPosition).Magnitude < 0.001 then
                predictedPosition = aimPartPos
            else
                local distance = (aimPartPos - lastPosition).Magnitude
                local predictedDistance = (distance / deltaTime) * (0.1 * (silentAimVars.Silent.PredictionXZ * 10))
                predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance

                local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * silentAimVars.Silent.PredictionY)
                predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
            end
        end

        lastUpdateTime = currentTime
        lastPosition = aimPartPos
        return predictedPosition
    end
    return nil
end

local function GetTargetAimPart(player)
    if not player or not player.Character then return silentAimVars.Silent.Part end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local state = humanoid:GetState()
        if state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
            return silentAimVars.Silent.AirPart or silentAimVars.Silent.Part
        end
    end
    return silentAimVars.Silent.Part
end

local function GetClosestPlayerToCursor()
    if not SilentAim or not SilentAim.Silent then return nil end
    
    local shortestDistance = math.huge
    local closestPlayer = nil
    local mousePosition = GetMouseLocation(UserInputService)
    for _, player in next, GetPlayers(Players) do
        if player and player.Character then
            if player ~= LocalPlayer and PassesChecks(player) and WallCheck(player.Character) then
                local partName = GetTargetAimPart(player)
                local targetPart = player.Character:FindFirstChild(partName)
                if targetPart then
                    local onScreenPosition, isOnScreen = WorldToViewportPoint(Camera, targetPart.Position)
                    if isOnScreen then
                        local distance = (NewVector2(onScreenPosition.X, onScreenPosition.Y) - mousePosition).Magnitude
                        if distance < shortestDistance then
                            closestPlayer = player
                            shortestDistance = distance
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end

local function GetKillAuraTargets()
    local targets = {}
    local part = SilentAim.Silent.Part
    for _, player in next, GetPlayers(Players) do
        if player and player.Character and player ~= LocalPlayer and PassesChecks(player) and WallCheck(player.Character) then
            local targetPart = player.Character:FindFirstChild(part)
            if targetPart then
                local onScreenPosition, isOnScreen = WorldToViewportPoint(Camera, targetPart.Position)
                if isOnScreen then
                    table.insert(targets, player)
                end
            end
        end
    end
    return targets
end

-- Handle sticky target key press
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and SilentAim and SilentAim.Misc and SilentAim.Misc.StickyTarget and input.KeyCode == SilentAim.Misc.StickyTarget.Key then
        if SilentAim.Misc.TargetMode == "Sticky" then
            if SilentAim.Misc.StickyTarget.Target then
                SilentAim.Misc.StickyTarget.Target = nil
            else
                SilentAim.Misc.StickyTarget.Target = GetClosestPlayerToCursor()
            end
        end
    end
end)

local function GetTargetPlayer()
    if not SilentAim or not SilentAim.Options or not SilentAim.Options.Enabled then return nil end
    if SilentAim.Misc.TargetMode == "Sticky" then
        local stickyTarget = SilentAim.Misc.StickyTarget.Target
        if stickyTarget and stickyTarget.Character and IsPlayerAlive(stickyTarget) and PassesChecks(stickyTarget) and WallCheck(stickyTarget.Character) then
            return stickyTarget
        end
        SilentAim.Misc.StickyTarget.Target = nil
        return nil
    elseif SilentAim.Misc.TargetMode == "KillAura" then
        local now = tick()
        local killaura = SilentAim.Misc.KillAura
        local targets = GetKillAuraTargets()
        if #targets == 0 then return nil end
        if killaura.Index > #targets then killaura.Index = 1 end
        if now - (killaura.LastSwitch or 0) > 0.01 then -- 20 раз в секунду
            killaura.Index = killaura.Index + 1
            if killaura.Index > math.min(#targets, killaura.MaxTargets) then
                killaura.Index = 1
            end
            killaura.LastSwitch = now
        end
        return targets[killaura.Index]
    else -- Nuker
        return GetClosestPlayerToCursor()
    end
end

-- TARGET INFO SYSTEM - Универсальная структура для хранения информации о цели
local isTarget = {
    Player = nil,
    Character = nil,
    Name = "",
    -- Основные части тела
    HumanoidRootPart = nil,
    Head = nil,
    Torso = nil,
    Humanoid = nil,
    -- Позиционные данные
    Position = Vector3.new(0, 0, 0),
    CFrame = CFrame.new(),
    Velocity = Vector3.new(0, 0, 0),
    -- Состояние
    Health = 0,
    MaxHealth = 0,
    IsAlive = false,
    IsKnocked = false,
    -- Расстояние и углы
    Distance = 0,
    ScreenPosition = Vector2.new(0, 0),
    OnScreen = false,
    -- Временные метки
    LastUpdate = 0,
    Valid = false
}

-- Функция обновления информации о цели
local function UpdateTargetInfo(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        isTarget.Valid = false
        isTarget.Player = nil
        isTarget.Character = nil
        return false
    end
    
    local character = targetPlayer.Character
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not hrp or not humanoid then
        isTarget.Valid = false
        return false
    end
    
    -- Обновляем всю информацию
    isTarget.Player = targetPlayer
    isTarget.Character = character
    isTarget.Name = targetPlayer.Name
    
    -- Части тела
    isTarget.HumanoidRootPart = hrp
    isTarget.Head = character:FindFirstChild("Head")
    isTarget.Torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    isTarget.Humanoid = humanoid
    
    -- Позиционные данные
    isTarget.Position = hrp.Position
    isTarget.CFrame = hrp.CFrame
    isTarget.Velocity = hrp.AssemblyLinearVelocity or hrp.Velocity or Vector3.new(0, 0, 0)
    
    -- Состояние
    isTarget.Health = humanoid.Health
    isTarget.MaxHealth = humanoid.MaxHealth
    isTarget.IsAlive = humanoid.Health > 0
    isTarget.IsKnocked = isPlayerKO and isPlayerKO(targetPlayer) or false
    
    -- Расстояние и экранные координаты
    local localPlayer = LocalPlayer
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        isTarget.Distance = (isTarget.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
    end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(isTarget.Position)
    isTarget.ScreenPosition = Vector2.new(screenPos.X, screenPos.Y)
    isTarget.OnScreen = onScreen
    
    -- Временные метки
    isTarget.LastUpdate = tick()
    isTarget.Valid = true
    
    return true
end

-- Функция получения актуальной цели с полной информацией
local function GetCurrentTarget()
    local targetPlayer = GetTargetPlayer()
    if UpdateTargetInfo(targetPlayer) then
        return isTarget
    end
    return nil
end

-- ORBIT KEYBIND HANDLER (использует новую систему isTarget)
UserInputService.InputBegan:Connect(function(input)
    if not orbitConfig.Enabled then return end
    if input.KeyCode == orbitConfig.Keybind then
        if TargPlr then
            -- Переключаем орбит вкл/выкл
            TargTp = not TargTp
            if not TargTp then
                TargPlr = nil
                print("[ORBIT] Орбит выключен")
            else
                print("[ORBIT] Орбит включен для: " .. TargPlr.Name)
            end
        else
            -- Получаем полную информацию о цели через isTarget
            local targetInfo = GetCurrentTarget()
            
            if targetInfo and targetInfo.Valid then
                TargPlr = targetInfo.Player
                TargTp = true
                print(string.format("[ORBIT] Орбит активирован!"))
                print(string.format("  Цель: %s", targetInfo.Name))
                print(string.format("  Здоровье: %.0f/%.0f", targetInfo.Health, targetInfo.MaxHealth))
                print(string.format("  Расстояние: %.1f", targetInfo.Distance))
                print(string.format("  Позиция: %.1f, %.1f, %.1f", targetInfo.Position.X, targetInfo.Position.Y, targetInfo.Position.Z))
                if targetInfo.IsKnocked then
                    print("  Состояние: Нокаут")
                elseif not targetInfo.IsAlive then
                    print("  Состояние: Мертв")
                else
                    print("  Состояние: Жив")
                end
            else
                print("[ORBIT] Нет доступной цели аимбота!")
                print("  Проверьте:")
                print("  - Включен ли аимбот")
                print("  - Есть ли игроки в поле зрения")
                print("  - Проходят ли цели проверки аимбота")
            end
        end
    end
end)

-- Initialize mouse variable
local Mouse = LocalPlayer:GetMouse()

local MetaTable = getrawmetatable(game)
local OldIndex = MetaTable.__index
setreadonly(MetaTable, false)

-- Update MetaTable.__index to use GetTargetPlayer instead of GetClosestPlayerToCursor
MetaTable.__index = function(self, key)
    if not checkcaller() and self == Mouse and silentAimVars.Options.Enabled then
        if key == "Hit" or key == "Target" then
            local targetPlayer = GetTargetPlayer()
            if targetPlayer and targetPlayer.Character then
                local partName = GetTargetAimPart(targetPlayer)
                local targetPart = targetPlayer.Character:FindFirstChild(partName)
                if targetPart then
                    local finalPosition
                    if silentAimVars.Misc.Checks.Resolver.Enabled then
                        finalPosition = getPredictedPosition(targetPlayer)
                    else
                        local velocity = targetPart.Velocity or Vector3.new(0, 0, 0)
                        finalPosition = targetPart.Position + (velocity * silentAimVars.Silent.PredictionXZ)
                    end

                    if finalPosition then
                        local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                finalPosition = finalPosition + Vector3.new(0, (silentAimVars.Silent.Offsets and silentAimVars.Silent.Offsets.Jump and silentAimVars.Silent.Offsets.Jump.Amount) or 0, 0)
                            elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                finalPosition = finalPosition + Vector3.new(0, (silentAimVars.Silent.Offsets and silentAimVars.Silent.Offsets.Fall and silentAimVars.Silent.Offsets.Fall.Amount) or 0, 0)
                            end
                        end
                        return key == "Hit" and NewCFrame(finalPosition) or targetPart
                    end
                end
            end
        end
    end
    return OldIndex(self, key)
end
setreadonly(MetaTable, true)

local function FixTool(character)
    if character then
        for _, v in next, character:GetChildren() do
            if IsA(v, "Tool") then
                local currentTool = v
                currentTool.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
                break
            end
        end
    end
end

FixTool(LocalPlayer.Character)

LocalPlayer.CharacterAdded:Connect(function(character)
    FixTool(character)
end)

-- ForceHit target storage
local forceHitTarget = {
    enabled = false,
    position = Vector3.new(0, 0, 0),
    part = nil
}

-- ForceHit functionality
local function updateForceHitTarget()
    if not silentAimVars.Silent.ForceHit.Enabled then
        forceHitTarget.enabled = false
        return
    end
    
    local targetPlayer = GetTargetPlayer()
    if targetPlayer and targetPlayer.Character then
        local partName = GetTargetAimPart(targetPlayer)
        local targetPart = targetPlayer.Character:FindFirstChild(partName)
        
        if targetPart then
            forceHitTarget.enabled = true
            forceHitTarget.position = targetPart.Position
            forceHitTarget.part = targetPart
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(updateForceHitTarget)

-- Magic Bullets functionality
local lastMagicBulletTime = 0
local function updateMagicBullets()
    if not silentAimVars.Silent.MagicBullets.Enabled then return end
    
    local currentTime = tick()
    if currentTime - lastMagicBulletTime < 0.05 then return end -- 20 shots per second max
    
    local targetPlayer = GetTargetPlayer()
    if not targetPlayer or not targetPlayer.Character then return end
    
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return end
    
    local handle = tool:FindFirstChild("Handle")
    if not handle then return end
    
    local targetPart = targetPlayer.Character:FindFirstChild(silentAimVars.Silent.Part)
    local targetHead = targetPlayer.Character:FindFirstChild("Head")
    
    if targetPart and targetHead then
        game:GetService("ReplicatedStorage").MainEvent:FireServer(
            "ShootGun",
            handle,
            handle.CFrame.Position,
            targetPart.Position,
            targetHead,
            Vector3.new(0, 0, -1)
        )
        lastMagicBulletTime = currentTime
    end
end

game:GetService("RunService").Heartbeat:Connect(updateMagicBullets)

-- Hooks storage to prevent recursion
local Hooks = {}

-- Update hook for ForceHit
Hooks.Remote = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local args = { ... }
    local method = getnamecallmethod():lower()

    if forceHitTarget.enabled and forceHitTarget.position and forceHitTarget.part and 
       method == "fireserver" and self.Name == "MainEvent" and args[1] == "ShootGun" then
        args[4] = forceHitTarget.position
        args[5] = forceHitTarget.part
        args[6] = Vector3.new(0, 0, 0)
        return Hooks.Remote(self, unpack(args))
    end

    return Hooks.Remote(self, ...)
end))

-- Initialize indicator
local RunService = game:GetService("RunService")
local RND = RunService.RenderStepped

-- Destroy existing indicator if it exists
if workspace:FindFirstChild("PP") then
    workspace.PP:Destroy()
end

-- Create new indicator
local Billboard = Instance.new("BillboardGui")
Billboard.Name = "PP"
Billboard.Size = UDim2.new(1, 0, 1, 0)  -- Base size that will be scaled
Billboard.AlwaysOnTop = true
Billboard.StudsOffset = Vector3.new(0, 0, 0)
Billboard.MaxDistance = math.huge  -- No max distance limit
Billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
Billboard.ResetOnSpawn = false
Billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local img3 = Instance.new("ImageLabel")
img3.Name = "img3"
img3.Size = UDim2.new(1, 0, 1, 0)  -- Fill the entire BillboardGui
img3.Position = UDim2.new(0.5, 0, 0.5, 0)
img3.AnchorPoint = Vector2.new(0.5, 0.5)
img3.BackgroundTransparency = 1
local selected = getgenv().IndicatorConfig.Selected or "skull"
img3.Image = "rbxassetid://" .. (indicatorImages[selected] or indicatorImages["skull"])
img3.Parent = Billboard

-- Create tracking part
local adorneePart = Instance.new("Part")
adorneePart.Name = "IndicatorPart"
adorneePart.Size = Vector3.new(1, 1, 1)
adorneePart.Transparency = 1
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Parent = workspace

Billboard.Adornee = adorneePart
Billboard.Parent = workspace

-- Update indicator position
RunService.RenderStepped:Connect(function()
    local billboard = workspace:FindFirstChild("PP")
    if not billboard then return end
    
    local adorneePart = workspace:FindFirstChild("IndicatorPart")
    if not adorneePart then return end
    
    local target = GetTargetPlayer()
    if target and target.Character and getgenv().IndicatorConfig.Enabled then
        local partName = GetTargetAimPart(target)
        local targetPart = target.Character:FindFirstChild(partName)
        
        if targetPart then
            local finalPosition
            if silentAimVars.Misc.Checks.Resolver.Enabled then
                finalPosition = getPredictedPosition(target)
            else
                local velocity = targetPart.Velocity or Vector3.new(0, 0, 0)
                finalPosition = targetPart.Position + (velocity * silentAimVars.Silent.PredictionXZ)
            end

            if finalPosition then
                -- Calculate scale based on distance
                local camPos = Camera.CFrame.Position
                local dist = (camPos - finalPosition).Magnitude
                local scale = math.clamp(dist/100, 1.5, 4.5)
                
                adorneePart.Position = finalPosition
                billboard.Size = UDim2.new(scale, 0, scale, 0)
                billboard.Enabled = true
                return
            end
        end
    end
    
    adorneePart.Position = Vector3.new(0, 0, 0)
    billboard.Enabled = false
end)

-- Hit detection logic for visual effects
local RND = game:GetService("RunService").RenderStepped

-- Hit sound function
local function PlayHitSound(hitsounds, config, SoundService)
    if config.Enabled and config.Selected and hitsounds[config.Selected] then
        local sound = Instance.new("Sound")
        sound.SoundId = hitsounds[config.Selected]
        sound.Volume = config.Volume or 0.5
        sound.PlaybackSpeed = config.Pitch or 1.0
        sound.Parent = SoundService
        sound:Play()
        sound.Ended:Connect(function()
            sound:Destroy()
        end)
    end
end

-- Реализация функции HitChams
local TweenService = game:GetService("TweenService")
function HitChams(Player, Config)
    if not (Config and Config.Enabled) then return end
    if Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
        Player.Character.Archivable = true
        local Cloned = Player.Character:Clone()
        Cloned.Name = "Player Clone"
        local BodyParts = {
            "Head", "UpperTorso", "LowerTorso",
            "LeftUpperArm", "LeftLowerArm", "LeftHand",
            "RightUpperArm", "RightLowerArm", "RightHand",
            "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
            "RightUpperLeg", "RightLowerLeg", "RightFoot"
        }
        for _, Part in ipairs(Cloned:GetChildren()) do
            if Part:IsA("BasePart") then
                local PartValid = false
                for _, validPart in ipairs(BodyParts) do
                    if Part.Name == validPart then
                        PartValid = true
                        break
                    end
                end
                if not PartValid then
                    Part:Destroy()
                end
            elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
                Part:Destroy()
            end
        end
        if Cloned:FindFirstChild("Humanoid") then
            Cloned.Humanoid:Destroy()
        end
        for _, BodyPart in ipairs(Cloned:GetChildren()) do
            if BodyPart:IsA("BasePart") then
                BodyPart.CanCollide = false
                BodyPart.Anchored = true
                BodyPart.Transparency = Config.Transparency
                BodyPart.Color = Config.Color
                BodyPart.Material = Config.Material
            end
        end
        if Cloned:FindFirstChild("Head") then
            local Head = Cloned.Head
            Head.Transparency = Config.Transparency
            Head.Color = Config.Color
            Head.Material = Config.Material
            if Head:FindFirstChild("face") then
                Head.face:Destroy()
            end
        end
        Cloned.Parent = game.Workspace
        local tweenInfo = TweenInfo.new(
            Config.Duration,
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.InOut,
            0,
            false
        )
        for _, BodyPart in ipairs(Cloned:GetChildren()) do
            if BodyPart:IsA("BasePart") then
                local tween = TweenService:Create(BodyPart, tweenInfo, { Transparency = 1 })
                tween:Play()
            end
        end
        task.delay(Config.Duration, function()
            if Cloned and Cloned.Parent then
                Cloned:Destroy()
            end
        end)
    end
end

-- Track target HP changes for hit effects
local lastTarget, lastHP
RND:Connect(function()
    local hitConfig = getgenv().HitSoundsConfig
    local chamsConfig = getgenv().HitChamsConfig
    local SoundService = game:GetService("SoundService")
    
    if not (chamsConfig and chamsConfig.Enabled) and not (hitConfig and hitConfig.Enabled) then
        lastTarget, lastHP = nil, nil
        return
    end
    
    local silentAim = getgenv().SilentAim
    local target = silentAim and (silentAim.currentTarget or GetTargetPlayer())
    
    if not target then 
        return 
    end
    
    if not target.Character then
        return
    end
    
    local humanoid = target.Character:FindFirstChild('Humanoid')
    if not humanoid then
        return
    end
    
    -- Теперь мы знаем что и Character и Humanoid существуют
    if target and target.Character and humanoid then
        local hum = target.Character.Humanoid
        local hp = nil
        local success, err = pcall(function()
            hp = hum.Health
        end)
        if not success then
            lastTarget, lastHP = nil, nil
            return
        end
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else
            if hp < lastHP then
                local damageDealt = lastHP - hp
                local selectedPart = GetTargetAimPart(target)
                -- Play hit sound
                PlayHitSound(hitsoundsList, hitConfig, SoundService)
                -- Apply hit chams
                if chamsConfig and chamsConfig.Enabled then
                    HitChams(target, chamsConfig)
                end
                -- Show damage notification (if we add UI Library later)
                if window and window.CreateNotification then
                    local damageText = string.format("%d", damageDealt)
                    local remainingValue = string.format("%d", math.max(hp, 0))
                    window:CreateNotification({
                        Title = "Hit",
                        Content = string.format("Hit %s on %s for %s (%s remaining)", 
                            target.DisplayName or target.Name,
                            selectedPart,
                            damageText,
                            remainingValue
                        ),
                        Duration = 1.5
                    })
                end
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
    end
end)

-- Highlight Target Logic
local currentHighlight = nil

-- Function to update highlight for target
local function updateHighlight(target)
    local config = getgenv().HighlightTargetConfig
    
    if not config or not config.Enabled then
        if currentHighlight then
            pcall(function()
                currentHighlight:Destroy()
                currentHighlight = nil
            end)
        end
        return
    end

    -- If highlight already exists, check if we need to move it to new target
    if currentHighlight then
        if not target or not target.Character or currentHighlight.Parent ~= target.Character then
            -- Target changed or disappeared, remove old highlight
            pcall(function()
                currentHighlight:Destroy()
                currentHighlight = nil
            end)
        end
    end

    -- If no highlight exists and target is valid, create new one
    if not currentHighlight and target and target.Character then
        pcall(function()
            local highlight = Instance.new("Highlight")
            
            -- Use Color1 for outline and Color2 for fill
            highlight.OutlineColor = Color3.fromRGB(
                config.Color1.R,
                config.Color1.G,
                config.Color1.B
            )
            highlight.FillColor = Color3.fromRGB(
                config.Color2.R,
                config.Color2.G,
                config.Color2.B
            )
            
            -- Use transparency settings
            highlight.OutlineTransparency = config.Transparency1
            highlight.FillTransparency = config.Transparency2
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = target.Character
            currentHighlight = highlight
        end)
    elseif currentHighlight and target and target.Character then
        -- Update existing highlight colors and transparency
        pcall(function()
            currentHighlight.OutlineColor = Color3.fromRGB(
                config.Color1.R,
                config.Color1.G,
                config.Color1.B
            )
            currentHighlight.FillColor = Color3.fromRGB(
                config.Color2.R,
                config.Color2.G,
                config.Color2.B
            )
            currentHighlight.OutlineTransparency = config.Transparency1
            currentHighlight.FillTransparency = config.Transparency2
        end)
    end
end

-- Connect highlight update to main game loop
RND:Connect(function()
    local silentAim = getgenv().SilentAim
    local target = silentAim and (silentAim.currentTarget or GetTargetPlayer())
    updateHighlight(target)
end)

local savePosConfig = getgenv().SavePosConfig or {
    Enabled = false,
    OffsetX = 0,
    OffsetY = 5,
    OffsetZ = 0
}
getgenv().SavePosConfig = savePosConfig

local savePosHeader = rageHeader:CollapsingHeader({
    Title = "SavePos"
})

savePosHeader:Checkbox({
    Label = "Enable SavePos",
    Value = savePosConfig.Enabled,
    Callback = function(self, value)
        savePosConfig.Enabled = value
    end
})
savePosHeader:Slider({
    Label = "Offset X",
    Value = savePosConfig.OffsetX,
    MinValue = -50,
    MaxValue = 50,
    Step = 0.1,
    Callback = function(self)
        savePosConfig.OffsetX = self:GetValue()
        return true
    end
})
savePosHeader:Slider({
    Label = "Offset Y",
    Value = savePosConfig.OffsetY,
    MinValue = -100,
    MaxValue = 100,
    Step = 0.1,
    Callback = function(self)
        savePosConfig.OffsetY = self:GetValue()
        return true
    end
})
savePosHeader:Slider({
    Label = "Offset Z",
    Value = savePosConfig.OffsetZ,
    MinValue = -50,
    MaxValue = 50,
    Step = 0.1,
    Callback = function(self)
        savePosConfig.OffsetZ = self:GetValue()
        return true
    end
})

-- Реализация SavePos (без плавности, сброс Velocity при отключении)
local lastTargetForSavePos = nil
local lastSavePosActive = false
local lastHadTarget = false
RunService.Heartbeat:Connect(function(dt)
    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local savePosActive = savePosConfig.Enabled
    local target = GetTargetPlayer and GetTargetPlayer() or nil
    local hasTarget = target and target.Character and target.Character:FindFirstChild(GetTargetAimPart(target))

    -- Сброс Velocity только при выключении SavePos (1 раз)
    if lastSavePosActive and not savePosActive then
        if myRoot then
            myRoot.Velocity = Vector3.new(0,0,0)
        end
    end
    -- Сброс Velocity только при потере цели (1 раз)
    if savePosActive and lastHadTarget and not hasTarget then
        if myRoot then
            myRoot.Velocity = Vector3.new(0,0,0)
        end
    end
    lastSavePosActive = savePosActive
    lastHadTarget = hasTarget and true or false

    if not savePosActive or not hasTarget then
        return
    end
    local targetPart = target.Character:FindFirstChild(GetTargetAimPart(target))
    local targetCFrame = targetPart.CFrame
    local offset = Vector3.new(savePosConfig.OffsetX, savePosConfig.OffsetY, savePosConfig.OffsetZ)
    local desiredPos = (targetCFrame * CFrame.new(offset)).p
    myRoot.CFrame = CFrame.new(desiredPos, targetPart.Position + targetPart.CFrame.LookVector*5)
end)

local viewTargetConfig = getgenv().ViewTargetConfig or { Enabled = false }
getgenv().ViewTargetConfig = viewTargetConfig

rageHeader:Checkbox({
    Label = "View target",
    Value = viewTargetConfig.Enabled,
    Callback = function(self, value)
        viewTargetConfig.Enabled = value
        if not value then
            -- Вернуть камеру на игрока
            local lp = game:GetService("Players").LocalPlayer
            local camera = game:GetService("Workspace").CurrentCamera
            if lp.Character then
                local playerHumanoid = lp.Character:FindFirstChildOfClass("Humanoid")
                if playerHumanoid then
                    camera.CameraSubject = playerHumanoid
                end
            end
        end
    end
})

local function setCameraToAimbotTarget(target)
    local camera = game:GetService("Workspace").CurrentCamera
    if target and target.Character then
        local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            camera.CameraSubject = humanoid
            return
        end
    end
    -- Если цели нет, вернуть камеру на игрока
    local lp = game:GetService("Players").LocalPlayer
    if lp.Character then
        local playerHumanoid = lp.Character:FindFirstChildOfClass("Humanoid")
        if playerHumanoid then
            camera.CameraSubject = playerHumanoid
        end
    end
end

RunService.Heartbeat:Connect(function()
    if viewTargetConfig.Enabled then
        local target = GetTargetPlayer and GetTargetPlayer() or nil
        setCameraToAimbotTarget(target)
    end
end)

-- TracerToTarget drawing functionality
local tracerLine = nil

-- Initialize tracer line
if Drawing then
    tracerLine = Drawing.new("Line")
    tracerLine.Visible = false
    tracerLine.Transparency = 1
end

-- Update tracer line
RunService.Heartbeat:Connect(function()
    local config = getgenv().TracerToTargetConfig
    
    if not config or not config.Enabled or not tracerLine then
        if tracerLine then
            tracerLine.Visible = false
        end
        return
    end
    
    local target = GetTargetPlayer and GetTargetPlayer() or nil
    
    if target and target.Character then
        local upperTorso = target.Character:FindFirstChild("UpperTorso")
        
        if upperTorso then
            local camera = workspace.CurrentCamera
            local userInputService = game:GetService("UserInputService")
            
            -- Get screen position of target's UpperTorso
            local targetScreenPos, onScreen = camera:WorldToViewportPoint(upperTorso.Position)
            
            if onScreen then
                -- Get accurate mouse position
                local mouseLocation = userInputService:GetMouseLocation()
                
                -- Update tracer line properties
                tracerLine.From = Vector2.new(mouseLocation.X, mouseLocation.Y)
                tracerLine.To = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                tracerLine.Color = Color3.fromRGB(config.Color.R, config.Color.G, config.Color.B)
                tracerLine.Thickness = config.Thickness
                tracerLine.Transparency = 1
                tracerLine.Visible = true
            else
                tracerLine.Visible = false
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- Speedhack keybind handler
S.UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == getgenv().SpeedhackConfig.Keybind then
        getgenv().ToggleSpeedhackKey()
    end
    -- FlyHack keybind handler
    if input.KeyCode == getgenv().FlyConfig.Keybind then
        getgenv().ToggleFlyKey()
    end
end)

getgenv().Loaded = true

